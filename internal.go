package chow

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"os"
	"os/exec"
	"syscall"
)

// The currently executing step.
var currentStep Step

func runRunnable(r Runnable, stdout io.Writer, stderr io.Writer) (err error) {
	// The framework will panic if any fatal errors occur. Recover from these panics so we
	// can report errors gracefully.
	defer func() {
		if r := recover(); r != nil {
			err = r.(error)
		}
	}()

	// Set the CWD as the directory in which execution started.
	startDir, err := os.Getwd()
	if err != nil {
		logFatal("failed to get working directory", err)
	}

	// Run the program.
	runner := &prodRunner{
		startDir: startDir,
		stdout:   stdout,
		stderr:   stderr,
		stepLog:  &JSONStepLogWriter{os.Stderr},
	}
	r(runner)
	return
}

type prodRunner struct {
	startDir string
	stdout   io.Writer
	stderr   io.Writer
	stepLog  StepLogWriter
}

// Run implements Runner
func (r *prodRunner) Run(name string, provider StepProvider) StepResult {
	currentStep = provider.Create()
	if err := r.convertAnyPaths(currentStep.Command); err != nil {
		logFatal("failed to convert paths in step command", err)
	}
	if err := r.convertAnyPaths(currentStep.Outputs); err != nil {
		logFatal("failed to convert paths in step outputs", err)
	}

	child := exec.Command(currentStep.Command[0], currentStep.Command[1:]...)

	// Capture stdout & stderr.  We still want to print the child's output for easy
	// debugging, so we also stream to the current stdout and stderr.
	outWriter := &recordingWriter{Delegate: r.stdout}
	errWriter := &recordingWriter{Delegate: r.stderr}

	child.Stdout = outWriter
	child.Stderr = errWriter

	// Start the child process
	if err := child.Start(); err != nil {
		logFatal("failed to start child process", err)
	}

	// Get the exit code.
	var exitCode int
	if err := child.Wait(); err != nil {
		exitCode = err.(*exec.ExitError).Sys().(syscall.WaitStatus).ExitStatus()
	}

	// Validate outputs.
	var missingOutputs Outputs
	for _, output := range currentStep.Outputs {
		_, err := os.Stat(output)
		if err != nil && os.IsNotExist(err) {
			missingOutputs = append(missingOutputs, output)
		}
	}
	if len(missingOutputs) > 0 {
		// Unsafe to continue execution. Abort.
		err := fmt.Errorf("ouputs are missing: %#v", missingOutputs)
		logFatal("declared outputs missing after step execution", err)
	}

	result := StepResult{
		Stdout:   outWriter.String(),
		Stderr:   errWriter.String(),
		ExitCode: exitCode,
	}

	// Report the step
	if err := r.stepLog.Write(StepLog{name, currentStep, result}); err != nil {
		logFatal("failed to log step", err)
	}

	return result
}

// A Runner that processes step invocations in tests.
//
// This Runner generates an "expection", which is a serialized chain of step invocations
// representing the set of shell commands that would have run in production.  The
// expectation is typically checked into the source tree and used as a golden-file to
// comparing the set shell-commands generated by of one version of the source to another.
type testRunner struct {
	// A list of functions that return Mock objects for certain step invocations.
	Mocks []Mock

	// Maps a Step types to the number of times the same type of Step has
	// been called.
	callCounts map[StepProvider]int

	stepLog StepLogWriter
}

// Run implements Runner
//
// This is called directly by the client's production code.
func (r *testRunner) Run(name string, provider StepProvider) StepResult {
	if r.callCounts == nil {
		r.callCounts = make(map[StepProvider]int)
	}

	// Record that this step has been called one more time.
	r.callCounts[provider]++

	// If there's a mock return value for the step, return it.  It's possible the user
	// registered multiple mocks in their test; In this case, the first one registered
	// wins because we search the list of mocks from 0...end.
	var stepResult StepResult
	matched := -1
	for i, mock := range r.Mocks {
		if mock.Step == name {
			stepResult = mock.Result
			matched = i
			break
		}
	}

	// Prevent the mock from matching other steps by removing it.
	if matched >= 0 {
		r.Mocks = append(r.Mocks[:matched], r.Mocks[matched+1:]...)
	}

	// Report the step
	step := provider.Create()
	if err := r.stepLog.Write(StepLog{name, step, stepResult}); err != nil {
		logFatal("failed to log step", err)
	}

	// Return the empty result.
	return stepResult
}

// Internal utiltity types

type recordingWriter struct {
	Delegate io.Writer
	buf      bytes.Buffer
}

func (w *recordingWriter) Write(b []byte) (int, error) {
	if n, err := w.buf.Write(b); err != nil {
		return n, err
	}
	return w.Delegate.Write(b)
}

func (w *recordingWriter) String() string {
	return w.buf.String()
}

type StepLogWriter interface {
	Write(StepLog) error
}

type JSONStepLogWriter struct {
	delegate io.Writer
}

func (w *JSONStepLogWriter) Write(s StepLog) error {
	bytes, err := json.MarshalIndent(s, "", "    ")
	if err != nil {
		return err
	}
	fmt.Fprintln(w.delegate, string(bytes))
	return nil
}
