package chow

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"syscall"
)

type logLevel string

var placeholders map[string]io.WriteCloser

const (
	fatal logLevel = "FATAL"
	warn           = "WARNING"
)

// stepLog is a log-entry for a step invocation.
//
// This is logged to the console in production and serialized into an expectation file
// during tests.
type stepLog struct {
	StepName   string     `json:"step_name"`
	Step       Step       `json:"step"`
	StepResult StepResult `json:"result"`
}

func runRunnable(r Runnable, stdout io.Writer, stderr io.Writer) (err error) {
	// The framework will panic if any fatal errors occur. Recover from these panics so we
	// can report errors gracefully.
	defer func() {
		if r := recover(); r != nil {
			err = r.(error)
		}
	}()

	// Set the CWD as the directory in which execution started.
	startDir, err := os.Getwd()
	if err != nil {
		logFatal("failed to get working directory", err, Step{})
	}

	runner := &prodRunner{
		startDir: startDir,
		stdout:   stdout,
		stderr:   stderr,
		stepLog:  &JSONStepLogWriter{os.Stderr},
	}

	// Run the program.
	r(runner)
	return
}

type prodRunner struct {
	currentStep Step
	startDir    string
	stdout      io.Writer
	stderr      io.Writer
	stepLog     StepLogWriter
}

// Run implements Runner
func (r *prodRunner) Run(name string, step Step) StepResult {
	r.currentStep = step
	if err := r.convertAnyPaths(r.currentStep.Command); err != nil {
		logFatal("failed to convert paths in step command", err, r.currentStep)
	}
	if err := r.convertAnyPaths(r.currentStep.Outputs); err != nil {
		logFatal("failed to convert paths in step outputs", err, r.currentStep)
	}

	child := exec.Command(r.currentStep.Command[0], r.currentStep.Command[1:]...)

	// Capture stdout & stderr.  We still want to print the child's output for easy
	// debugging, so we also stream to the current stdout and stderr.
	outWriter := &recordingWriter{Delegate: r.stdout}
	errWriter := &recordingWriter{Delegate: r.stderr}

	child.Stdout = outWriter
	child.Stderr = errWriter

	// Start the child process
	if err := child.Start(); err != nil {
		logFatal("failed to start child process", err, r.currentStep)
	}

	// Get the exit code.
	var exitCode int
	if err := child.Wait(); err != nil {
		exitCode = err.(*exec.ExitError).Sys().(syscall.WaitStatus).ExitStatus()
	}

	// Validate outputs.
	var missingOutputs Outputs
	for _, output := range r.currentStep.Outputs {
		_, err := os.Stat(output)
		if err != nil && os.IsNotExist(err) {
			missingOutputs = append(missingOutputs, output)
		}
	}
	if len(missingOutputs) > 0 {
		// Unsafe to continue execution. Abort.
		err := fmt.Errorf("ouputs are missing: %#v", missingOutputs)
		logFatal("declared outputs missing after step execution", err, r.currentStep)
	}

	result := StepResult{
		Stdout:   outWriter.String(),
		Stderr:   errWriter.String(),
		ExitCode: exitCode,
	}

	// Report the step
	if err := r.stepLog.Write(stepLog{name, r.currentStep, result}); err != nil {
		logFatal("failed to log step", err, r.currentStep)
	}

	return result
}

// Converts the input path to an absolute path for the current platform.
//
// The path is expected to have a Unix-style syntax, using '/' as the path separator.  The
// caller may refer to the "root" of the current task using '//', and the current working
// directory as './'.
func (r *prodRunner) convertAnyPaths(paths []string) error {
	for i, p := range paths {
		// Current working directory
		if strings.HasPrefix(p, "//CWD/") {
			wd, err := os.Getwd()
			if err != nil {
				return fmt.Errorf("failed to get cwd: %v", err)
			}

			suffix := strings.SplitN(p, "//CWD/", 2)[1]
			paths[i] = filepath.FromSlash(wd + "/" + suffix)
			continue
		}

		// Placeholder
		if strings.HasPrefix(p, "//ph/") {
			id := strings.SplitN(p, "//ph/", 2)[1]
			file := placeholders[id]
			// TODO: Find a way to close the file handle.
			paths[i] = file.(*os.File).Name()
			continue
		}

		// Start dir
		// TODO: Make this 3 slashes.
		if strings.HasPrefix(p, "//") {
			suffix := strings.SplitN(p, "//", 2)[1]
			r.startDir = strings.TrimRight(r.startDir, "/")
			paths[i] = filepath.FromSlash(r.startDir + "/" + suffix)
			continue
		}

		// Arbitrary absolute path
		// TODO: Remove this warning, since a forward slash does not always indicate a
		// path.
		if strings.HasPrefix(p, "/") {
			logWarning("unsafe use of absolute path "+p, r.currentStep)
			paths[i] = filepath.FromSlash(p)
			continue
		}
		// Ignore relative paths and non-path arguments
	}

	return nil
}

// A Runner that processes step invocations in tests.
//
// This Runner generates an "expection", which is a serialized chain of step invocations
// representing the set of shell commands that would have run in production.  The
// expectation is typically checked into the source tree and used as a golden-file to
// comparing the set shell-commands generated by of one version of the source to another.
type testRunner struct {
	// A list of functions that return Mock objects for certain step invocations.
	Mocks      []Mock
	callCounts map[string]int
	stepLog    StepLogWriter
}

// Run implements Runner
//
// This is called directly by the client's production code.
func (r *testRunner) Run(name string, step Step) StepResult {
	if r.callCounts == nil {
		r.callCounts = make(map[string]int)
	}

	// Record that this step has been called one more time.
	if i, ok := r.callCounts[name]; ok {
		name = fmt.Sprintf("%s %d", name, i)
	}
	r.callCounts[name]++

	// If there's a mock return value for the step, return it.  It's possible the user
	// registered multiple mocks in their test; In this case, the first one registered
	// wins because we search the list of mocks from 0...end.
	var stepResult StepResult
	matched := -1
	for i, mock := range r.Mocks {
		if mock.Step == name {
			stepResult = mock.Result
			matched = i
			break
		}
	}

	// Prevent the mock from matching other steps by removing it.
	if matched >= 0 {
		r.Mocks = append(r.Mocks[:matched], r.Mocks[matched+1:]...)
	}

	// Report the step
	if err := r.stepLog.Write(stepLog{name, step, stepResult}); err != nil {
		logFatal("failed to log step", err, step)
	}

	// Return the empty result.
	return stepResult
}

func (*testRunner) registerPlaceholder(content string) string {
	return "[placeholder]"
}

// Internal utiltity types

type recordingWriter struct {
	Delegate io.Writer
	buf      bytes.Buffer
}

func (w *recordingWriter) Write(b []byte) (int, error) {
	if n, err := w.buf.Write(b); err != nil {
		return n, err
	}
	return w.Delegate.Write(b)
}

func (w *recordingWriter) String() string {
	return w.buf.String()
}

type StepLogWriter interface {
	Write(stepLog) error
}

type JSONStepLogWriter struct {
	delegate io.Writer
}

func (w *JSONStepLogWriter) Write(s stepLog) error {
	bytes, err := json.MarshalIndent(s, "", "    ")
	if err != nil {
		return err
	}
	fmt.Fprintln(w.delegate, string(bytes))
	return nil
}
